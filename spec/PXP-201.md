# PXP-201 — Privacyx Encryption Standard (Draft v0.1)

PXP-201 defines an interoperable **encryption envelope** format for Web2 + Web3.
It standardizes how to:
- encrypt a payload (off-chain or on-chain referenced),
- describe access control (recipients or policy),
- wrap/unlock the Data Encryption Key (DEK),
- verify integrity before decrypting.

## 1. Goals

- **Encrypt once, share many** (multi-recipient support via wrapped keys).
- **Interoperable envelope JSON** (SDK-friendly, storage-agnostic).
- **Web3 compatibility**: recipients can be DID / wallet identifiers.
- **Policy-ready**: future mode for external policy engines / issuers.
- **Minimal on-chain surface**: on-chain stores references + commitments, not secrets.

Non-goals (v0.1):
- full policy engine on-chain,
- threshold / proxy re-encryption,
- post-quantum.

## 2. Terminology

- **Payload**: raw bytes to protect (stored off-chain or on-chain).
- **DEK**: 32-byte symmetric key used to encrypt the payload.
- **Envelope**: JSON metadata describing cipher, access, and integrity commitments.
- **WrappedKey**: recipient-specific encrypted DEK blob.

## 3. Envelope format (v0.1)

Envelope MUST be a JSON object matching:

\`\`\`json
{
  "v": "0.1",
  "typ": "PXP201",
  "cipher": "AES-256-GCM",
  "kdf": "HKDF-SHA256",
  "access": { ... },
  "uri": "ipfs://...",
  "ciphertextHash": "0x...",
  "aadHash": "0x...",
  "meta": { "mime": "text/plain" },
  "createdAt": 1700000000
}
\`\`\`

### 3.1 Fields
v (string): envelope version. MUST be "0.1".

typ (string): MUST be "PXP201".

cipher (string): payload cipher. v0.1 supports:

"AES-256-GCM"

kdf (string): key derivation identifier. MUST be "HKDF-SHA256".

access (object): access control block (see §4).

uri (string): location reference to ciphertext (storage-agnostic).

MUST be a non-empty string of length >= 3.

ciphertextHash (0x hex 32 bytes): sha3-256(ciphertextBytes)

aadHash (optional, 0x hex 32 bytes): sha3-256(aadBytes) if AAD used.

meta (optional object): freeform metadata (mime type, filename, etc).

createdAt (optional uint): unix seconds.

### 3.2 Integrity semantics
Before attempting decryption, implementers MUST recompute:

sha3-256(ciphertextBytes) and compare to ciphertextHash.
If mismatch: reject.

If AAD is provided by caller, and aadHash exists, implementers SHOULD verify:

sha3-256(aadBytes) == aadHash

Hash function v0.1:

sha3-256 (NIST SHA-3-256).

## 4. Access block
### 4.1 Mode: RECIPIENTS
\`\`\`json
{
  "mode": "RECIPIENTS",
  "kem": "RECIPIENTS-SECP256K1-ECIES",
  "recipients": [
    { "rid": "did:pkh:eip155:1:0x...", "wrappedKey": "pxp201:wk1:..." }
  ]
}
\`\`\`
Rules:

recipients MUST be a non-empty array.

rid is a recipient identifier (DID recommended).

wrappedKey encodes the DEK encrypted for that recipient.

Supported kem in v0.1:

RECIPIENTS-SECP256K1-ECIES using wk1 (see §5).

### 4.2 Mode: POLICY (reserved)
\`\`\`json
{
  "mode": "POLICY",
  "kem": "POLICY-EXTERNAL",
  "policy": { "policyId": "..." }
}
\`\`\`
v0.1 reserves this shape for future policy engines.
No canonical decryption flow is specified in v0.1.

## 5. WrappedKey format: wk1 (v0.1)
WrappedKey is a string with prefix:

pxp201:wk1:<b64url(JSON)>

Decoded JSON payload:

\`\`\`json
{
  "alg": "ECIES-secp256k1+HKDF-SHA256+AES-256-GCM",
  "epk": "0x02..",   // 33-byte compressed secp256k1 pubkey
  "nonce": "<b64url(12)>",
  "ct": "<b64url(ciphertext+tag)>",
  "kid": "optional key id"
}
\`\`\`
### 5.1 wk1 encryption (wrap)
Inputs:

dek (32 bytes)

recipient pubkey (compressed secp256k1, 33 bytes)

optional aadText (bytes)

Steps:

Generate ephemeral secp256k1 keypair (ephPriv, ephPub).

Compute shared secret:
ss = ECDH(ephPriv, recipientPub) (33 bytes, includes prefix).
ikm = ss[1..] (32 bytes).

Derive wrap key:

HKDF-SHA256

IKM = ikm

salt = ephPub (33 bytes)

info = UTF-8 "PXP201:WK1"

length = 32 bytes

Encrypt dek with AES-256-GCM using wrap key:

iv = 12 random bytes

aad = UTF-8(aadText) if provided

output ct includes auth tag

Emit wk1 JSON:

epk = ephPub hex (0x…)

nonce = b64url(iv)

ct = b64url(ct)

kid optional

### 5.2 wk1 decryption (unwrap)
Inputs:

recipient privkey (32 bytes)

epk, nonce, ct, optional aadText

Steps:

Compute shared secret:
ss = ECDH(recipientPriv, epk)
ikm = ss[1..]

Derive same wrap key with HKDF-SHA256:

salt = epk

info = "PXP201:WK1"

AES-256-GCM decrypt ct using nonce and aad.

Output must be 32 bytes DEK.

## 6. Reference SDK (v0.1)
The reference implementation provides:

encryptTextRaw

decryptTextFromEnvelope

wrapDEK_secp256k1

unwrapDEK_secp256k1

validateEnvelope

## 7. Security considerations
Never store DEKs in plaintext.

Use authenticated encryption (AES-GCM) and verify integrity before decrypt.

AAD should bind context (app id, chain id, epoch) to prevent replay across contexts.

wk1 uses fresh ephemeral keys per wrap to provide forward secrecy per recipient key.

## 8. Roadmap
v0.2: policy mode baseline, better recipient discovery, optional X25519 profile.

v0.3: optional on-chain registry interface (PXP-201 contracts).

v1.0: stable profiles + formal test vectors + audits.


---

## Test vectors (v0.1)

This section provides reproducible test vectors for **PXP-201 v0.1**.

Reference implementation: `@privacyx/pxp201` (see `sdk/test-vectors/`).

### RAW — AES-256-GCM (fixed DEK + nonce)

**Inputs**
- `plaintext`: `"hello"`
- `aadText`: `"aad"`
- `dekHex` (32 bytes): `0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f`
- `nonceB64url` (12 bytes): `AQIDBAUGBwgJCgsM`

**Outputs**
- `ciphertextB64url` (ciphertext || tag): `bY82uYOWXH2ko8D10wN-PjvA0wEg`
- `ciphertextHash` (SHA3-256): `0x6f3e82bf861ccfb90d55d184ff711a751e100925e3f90feb001daa5d4b9abf46`
- `aadHash` (SHA3-256): `0x95162aaa1b13769d45cdbd839920405271c89e40b58c41abc88928208e266c0c`

### WK1 — RECIPIENTS-SECP256K1-ECIES (fixed ephPriv + IV)

WK1 wraps a 32-byte DEK using:
- secp256k1 ECDH (shared secret)
- HKDF-SHA256 (info = `"PXP201:WK1"`, salt = `epk`)
- AES-256-GCM (wrap key, AAD = `aadText`)

**Inputs**
- `aadText`: `"aad"`
- `kid`: `did:pkh:eip155:1:0xDEMO`
- `dekHex` (32 bytes): `0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f`
- `recipientPrivHex` (32 bytes): `0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20`
- `ephPrivHex` (32 bytes): `0x1111111111111111111111111111111111111111111111111111111111111111`
- `wrapIvHex` (12 bytes): `0x222222222222222222222222`

**Output**
- `wrappedKey`:
  `pxp201:wk1:eyJhbGciOiJFQ0lFUy1zZWNwMjU2azErSEtERi1TSEEyNTYrQUVTLTI1Ni1HQ00iLCJlcGsiOiIweDAzNGYzNTViZGNiN2NjMGFmNzI4ZWYzY2NlYjk2MTVkOTA2ODRiYjViMmNhNWY4NTlhYjBmMGI3MDQwNzU4NzFhYSIsIm5vbmNlIjoiSWlJaUlpSWlJaUlpSWlJaSIsImN0IjoickZnT0hoNHVPWi1DcWZMZmg4UDZQYkgyNU40RlVldGNvNXQzSk5fUGxzZlI0R1dHRFlnSmFzY0lMZlhYVXZqNyIsImtpZCI6ImRpZDpwa2g6ZWlwMTU1OjE6MHhERU1PIn0`

### Running vectors (reference)

From `sdk/`:

```bash
npm run build
npm run vectors
```

> Note: deterministic options (`nonce`, `opts.ephPrivKey`, `opts.iv`) are intended for test vectors only.
